#pylint: disable-msg=protected-access
import logging
import re
import zipfile
from pathlib import Path

from django.contrib import messages
from django.contrib.auth.decorators import login_required, permission_required
from django.db.models.fields.related import RelatedField
from django.shortcuts import render, redirect
from django.utils.html import format_html
from django.utils.safestring import mark_safe

from meals.bulk_import import (
    has_ongoing_transaction,
    get_transaction,
    clear_transaction,
    force_save,
)
from meals.exceptions import CollisionOccurredException
from ..forms import ImportCsvForm, ImportZipForm

IMPORT_PERMISSIONS = (
    "meals.add_sku",
    "meals.change_sku",
    "meals.add_ingredient",
    "meals.change_ingredient",
    "meals.add_skuingredient",
    "meals.change_skuingredient",
)

logger = logging.getLogger(__name__)


def _render_collision(collision):
    """Renders a collision as two table entries (<td>s)"""
    old, new = collision.old_record, collision.new_record
    if not new.pk:
        new.pk = "<Autogenerated>"
    differences = {}
    for field in old._meta.fields:
        if field.primary_key:
            continue
        old_value = str(getattr(old, field.name, None))
        new_value = str(getattr(new, field.name, None))
        if isinstance(field, RelatedField):
            old_value = str(old_value)
            new_value = str(new_value)
        if old_value != new_value:
            differences[field.verbose_name] = (old_value, new_value)

    old_ul = ""
    new_ul = ""
    for field_name, (old_value, new_value) in differences.items():
        if not old_value:
            old_value = "<empty>"
        if not new_value:
            new_value = "<empty>"
        old_ul += format_html("<li>{}</li>", f"{field_name}: {old_value}")
        new_ul += format_html("<li>{}</li>", f"{field_name}: {new_value}")
    old_ul = format_html("<ul>{}</ul>", mark_safe(old_ul))
    new_ul = format_html("<ul>{}</ul>", mark_safe(new_ul))
    return format_html(
        "<td>{}</td><td>{}</td><td>{}</td>",
        old.pk,
        mark_safe(old_ul),
        mark_safe(new_ul),
    )


@login_required
@permission_required(IMPORT_PERMISSIONS, raise_exception=True)
def import_page(request):

    if request.method == "POST":
        csv_file_form = ImportCsvForm(
            request.POST, request.FILES, session_key=request.session.session_key
        )
        zip_file_form = ImportZipForm(request.POST, request.FILES)
        if csv_file_form.has_changed() and zip_file_form.has_changed():
            messages.error(
                request, "You can only upload CSV file(s) or a ZIP file, but not both."
            )
            return render(
                request,
                template_name="meals/import/import.html",
                context={
                    "csv_form": ImportCsvForm(session_key=request.session.session_key),
                    "zip_form": ImportZipForm(),
                },
            )
        if zip_file_form.has_changed():
            csv_files = {}
            if zip_file_form.is_valid():
                zip_file = zipfile.ZipFile(zip_file_form.cleaned_data["zip"])
                names = zip_file.namelist()

                for path in names:
                    name = Path(path).name
                    if re.match(r"skus(\S)*\.csv", name):
                        csv_files["skus"] = zip_file.open(path)
                    elif re.match(r"ingredients(\S)*\.csv", name):
                        csv_files["ingredients"] = zip_file.open(path)
                    elif re.match(r"product_lines(\S)*\.csv", name):
                        csv_files["product_lines"] = zip_file.open(path)
                    elif re.match(r"formula(\S)*\.csv", name):
                        csv_files["formulas"] = zip_file.open(path)
                    else:
                        logger.warning("Ignored unrecognized path: %s", path)
                csv_file_form = ImportCsvForm(
                    request.POST, csv_files, session_key=request.session.session_key
                )
        if csv_file_form.has_changed():
            try:
                if not csv_file_form.is_valid():
                    return render(
                        request,
                        template_name="meals/import/import.html",
                        context={"csv_form": csv_file_form, "zip_form": zip_file_form},
                    )
            except CollisionOccurredException:
                redirect("collision")
            if csv_file_form.imported:
                return import_success(request, inserted=csv_file_form.cleaned_data)
            return redirect("collision")

    clear_transaction(request.session.session_key)
    logger.info("Cleared transaction cache")
    csv_file_form = ImportCsvForm(session_key=request.session.session_key)
    zip_file_form = ImportZipForm()
    return render(
        request,
        template_name="meals/import/import.html",
        context={"csv_form": csv_file_form, "zip_form": zip_file_form},
    )


@login_required
def collision(request):
    if not has_ongoing_transaction(request.session.session_key):
        logger.warning("Session has no ongoing transaction. Redirecting to import.")
        return redirect("import")
    force = request.GET.get("force", "0") == "1"
    if not force:
        transaction = get_transaction(request.session.session_key)

        rendered_transaction = []
        total_conflicts = 0
        for filename in sorted(transaction.keys()):
            _, collisions = transaction[filename]
            total_conflicts += len(collisions)
            rendered_transaction.append(
                (filename, [_render_collision(c) for c in collisions])
            )

        return render(
            request,
            template_name="meals/import/collisions.html",
            context={
                "transaction": rendered_transaction,
                "total_conflicts": total_conflicts,
            },
        )
    inserted, updated = force_save(session_key=request.session.session_key, force=force)
    if inserted or updated:
        return import_success(request, inserted, updated)
    messages.error(
        request, "Unable to finish import. Please contact the administrator."
    )
    return redirect("error")


@login_required
def import_success(request, inserted=None, updated=None):
    if inserted is None:
        inserted = {}
    if updated is None:
        updated = {}
    response = render(
        request,
        template_name="meals/import/import_success.html",
        context={"inserted": inserted.items(), "updated": updated.items()},
    )
    return response
